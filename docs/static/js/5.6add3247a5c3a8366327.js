webpackJsonp([5],{"yd+H":function(r,n){r.exports='# 跨域\r\n\r\n在前端实际开发过程中，只要使用了Ajax等基于 `XMLHttpRequest` 的技术（$Ajax，axios）或者是fetch，无可避免都地会遇到浏览器的跨域问题。就算你请求的是自己本地计算机上的文件，在没有设置跨域的情况下，浏览器照样会阻止你的请求。这种限制让人非常抓狂，我居然都不能访问我自己本地的文件。因此，了解这背后的罪魁祸首（误），也就是浏览器的**同源策略**，和规避同源策略的方法，也就是**跨域**，是很有必要的:sunglasses:。\r\n\r\n通过阅读下面的内容，你将会了解到：\r\n\r\n* 为什么要有同源策略？\r\n* 如何实现跨域？\r\n    * Jsonp\r\n    * 反向代理\r\n    * CORS\r\n\r\n## 为什么要有同源策略？\r\n\r\n跨域问题来自于浏览器的[同源策略](https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy)，所谓**同源**指的是两个源（Origin）的协议，域名，端口号相同，否则就不属于同一个源。举例来说，对于 `http://www.github.com/index.html` ，协议是 `http` ，域名是 `www.github.com` ，端口号是 `80` （http协议的默认端口号是80），因此：\r\n\r\n* `http://www.github.com/index2.html`：同源\r\n* `http://github.com/index.html`：不同源（域名不同）\r\n* `https://www.github.com/index.html`：不同源（协议不同）\r\n* `http://www.github.com:81/index.html`：不同源（端口不同）\r\n\r\n### 含义\r\n\r\n浏览器的**同源策略**，就是指在未经允许的情况下，一个源（比如 `www.github.com` ）不能访问另一个源（比如 `www.wikipedia.org` ）中的内容。准确的来说，同源策略主要是阻止了JavaScript脚本，对另一个域下的：\r\n\r\n* 敏感信息数据：Cookie，LocalStorage，IndexDB\r\n* DOM\r\n* AJAX 请求\r\n\r\n的操作。大部分情况下，是浏览器主动拦截了这些操作和请求的发出。当然有些情况下，可能是请求已经发送到服务器了，但是响应被浏览器拦截了。\r\n\r\n除此之外，现代的浏览器也限制了对本地文件的访问。准确地说，如果请求的 URL 不是 HTTP 或者 HTTPS，而是 `file:///` 这样的形式，那么依然不符合同源策略，就算你使用了跨域，浏览器照样会进行拦截，详见[这里](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS/Errors/CORSRequestNotHttp)。可以说，随着互联网的发展，同源政策变得越来越严格。\r\n\r\n### 作用\r\n\r\n同源政策的作用就是为了防止某个网页上的恶意脚本访问另一个页面上的敏感数据。因为Web应用广泛依赖于Cookie来记录用户的状态信息，因此必须将不相关的网页隔离开来，防止敏感数据泄露。\r\n>设想这样一种情况：A网站是一家银行，用户登录以后，又去浏览其他网站。如果其他网站可以读取A网站的 Cookie，那么这些信息就会泄漏。更可怕的是，Cookie 往往用来保存用户的登录状态，如果用户没有退出登录，其他网站就可以冒充用户，为所欲为。由此可见，"同源政策"是必需的，否则 Cookie 可以共享，互联网就毫无安全可言了。\r\n\r\n现在你明白为什么需要有同源策略这种限制了吧？同源策略可以说是浏览器安全的基石，没有它 "互联网就毫无安全可言了" 。遗憾的是，同源策略不能完全避免所有的网络攻击（比如跨站请求伪造CSRF）。\r\n\r\n## 实现跨域\r\n\r\n实际开发中的跨域问题主要是出现在使用Ajax获取其他源上的数据，为了规避同源策略的影响，我们将在下面介绍三种常用的跨域方法。虽然跨域还有其他许多方案，不过应用场景都太少了，了解下面这三种就差不多了。\r\n\r\n### JSONP\r\n\r\nJSONP是最经典的跨域方式，JSONP全称是JSON with Padding（JSONP和JSON不是同一个东西，JSONP是获取JSON字符串的一种**方式**，也就是说：JSON是我的目的，JSONP是我的手段）。JSONP的原理是应用了HTML的 `<script>` 标签不受同源策略限制的特性来实现跨域的。也正是因为如此，JSONP只能支持GET请求（script标签的src只能是GET请求），也容易收到跨站脚本（XSS）的攻击。此外，JSONP的实现还需要服务器的配合。\r\n\r\nJSONP首先需要创建一个 `<script>` 标签，由标签的src属性向服务器发起请求，服务器会返回一段JavaScript代码。由于返回的是JavaScript代码，浏览器收到响应后就会立即执行，这和通过 `<script>` 标签引入Vue.js一样（`<script src="https://unpkg.com/vue@2.6.11/dist/vue.min.js"><\/script>`）。\r\n\r\nJSONP由两部份组成：**回调函数**和**数据**，JSONP的具体步骤为：\r\n* 浏览器端先创建一个回调函数 `JSONPCallback`。\r\n    ``` javascript\r\n    function JSONPCallback(response){\r\n        console.log(\'The request data is: \', response.data)\r\n    }\r\n    ```\r\n* 再创建一个 `<script>` 标签，标签的src属性加上回调函数名：\r\n    ``` javascript\r\n    <script src="http://www.github.com/id?callback=JSONPCallback"><\/script>\r\n    ```\r\n* 服务器端需要配合浏览器端，将需要返回的数据作为参数与回调函数名组合在一起：`JSONPCallback({data: \'someDataFromServer\'})`。\r\n* 浏览器收到响应后，立即执行返回的JS代码，也就相当于直接调用了预先在浏览器端设置好了的 `JSONPCallback` 函数。从而实现跨域。\r\n'}});