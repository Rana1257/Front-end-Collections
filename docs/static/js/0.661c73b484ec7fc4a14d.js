webpackJsonp([0],{mPYK:function(n,e){n.exports='# 面经汇总\n\n## 七牛云一面 60min\n\n对本次面试进行复盘总结之前，先来谈一下面试体验好了：\n\n面试官人非常nice，遇到不会的问题，写不出来的代码，他会一直引导你带你实现，主要是面试官**颜值爆表**！！！hhhh~\n\n问题总结：\n\n1、项目中的轮播是如何实现的？ 如果让你手写一个轮播效果，你会如何实现？\n\n2、在频繁触摸的情况下，有使用什么优化吗？\n\n3、打开屏幕共享实现以下函数节流？能不能修改成一个比较通用的函数？写的指示变量是在全局环境下的，有什么办法可以避免全局变量污染呢？\n\n4、函数防抖也写一下？\n\n5、像你的项目中一个页面比较长，会有很多的图片，如果同时加载过来的话性能肯定是比较低的，有什么方法优化呢？\n\n6、写一个深比较函数`function deepCompaire(a, b){ }` ，a和b是两个对象，如果相同输出为true，如果不同输出为false\n\n7、在实现上述深比较函数时用到了数组去重，不要用ES6的Set，自己写一个数组去重函数？\n\n8、 优化这个深比较函数，一个对象中的某个属性值可能是undefined，如何过滤掉这种情况？\n\n9、CSS选择器的优先级说一下\n\n10、写一段代码，说出输出结果。\n\n\n\n接下来，依次对上述问题进行分析总结：\n\n### 1、项目中的轮播是如何实现的？\n\n回答使用的是vue-awesome-swiper插件，说完立马就开始让我实现一个轮播了！回答的不好，当时确实思路不太清晰\n\n#### 1.1 实现一个最简单的轮播图\n\n效果描述：有6张图片，在轮播框的下放有对应的6个序号，鼠标放在对应的序号上显示对应的图片：\n\n布局：\n\n```html\n<div class="box" id="box">\n    <div class="inner">\n        \x3c!--相框--\x3e\n        <ul>\n            <li>\n                <a href="#"><img src="images/1.jpg" alt="" /></a>\n            </li>\n            <li>\n                <a href="#"><img src="images/2.jpg" alt="" /></a>\n            </li>\n            <li>\n                <a href="#"><img src="images/3.jpg" alt="" /></a>\n            </li>\n            <li>\n                <a href="#"><img src="images/4.jpg" alt="" /></a>\n            </li>\n            <li>\n                <a href="#"><img src="images/5.jpg" alt="" /></a>\n            </li>\n            <li>\n                <a href="#"><img src="images/6.jpg" alt="" /></a>\n            </li>\n        </ul>\n        <div class="square">\n            <span class="current">1</span>\n            <span>2</span>\n            <span>3</span>\n            <span>4</span>\n            <span>5</span>\n            <span>6</span>\n        </div>\n    </div>\n</div>\n```\n\n轮播实现：\n\n```javascript\n<script>\n\tvar box = my$("box"); // 获取最外面的div\n\tvar inner = box.children[0]; // 获取相框\n\tvar imgWidth = inner.offsetWidth; // 获取相框的宽度\n\tvar ulObj = inner.children[0]; // 获取ul\n\tvar spanObjs = inner.children[1].children;  // 获取所有的span\n\n\tfor (var i = 0; i < spanObjs.length; i++) { // 循环遍历所有的span标签，注册鼠标进入事件\n\n    \tspanObjs[i].setAttribute("idx", i); //循环时，把索引值保存在每个span的自定义属性中\n    \tspanObjs[i].onmouseover = function() { // 注册鼠标进入事件\n            for (var j = 0; j < spanObjs.length; j++) { //先干掉所有span的背景颜色\n                spanObjs[j].removeAttribute("class"); //移除每个spand的类样式\n            }\n\n        \tthis.className = "current";  //设置当前的span的背景颜色\n\n        \t//移动ul----每个图片的 宽 × 鼠标所在的span的索引值\n        \t//获取当前鼠标进入的span的索引值\n        \tvar idx = this.getAttribute("idx");\n        \tanimate(ulObj, -idx * imgWidth);\n    \t};\n\t}\n\n    function animate(element, target) {\n        clearInterval(element.timeid);\n\n        element.timeid = setInterval(function() { // 设置定时器\n\n            var cur = element.offsetLeft; // 获取div的初始位置\n            var stp = 10; //   设置移动步数\n\n            stp = cur < target ? stp : -stp; //当前位置的值小于目标位置的值的话就是从左往右走， 步数是正数，  否则， 就是从右往左走，  步数是负数\n\n            cur += stp;  // 获取每次移动后的位置\n            //   判断是否到达目标位置，没到的话就设置div当前的位置，如果到了的话就清除定时器\n            if (Math.abs(target - cur) > Math.abs(stp)) { //  涉及到  从左往右走 与从右往左走  的问题  ，  注意： 是距离的比较\n                element.style.left = cur + "px";\n            } else {\n                clearInterval(element.timeid);\n                element.style.left = target + "px"; //如果每次移动的步数不是整数10的话，  就会出现到不了目标位置的现象， 这个时候不需要再走10步，直接设置为目标位置就可以了\n            }\n        }, 20);\n    }\n<\/script>\n```\n\n\n\n#### 1.2 实现一个带有左右焦点的轮播图\n\n效果描述： 6张图片，点击右侧焦点时实现往左移动，点击左侧的焦点时往右移动。\n\n布局：\n\n```html\n<div id="box" class="all">\n        <div class="ad">\n            \x3c!--相框--\x3e\n            <ul id="imgs">\n                <li><img src="images/01.jpg" alt=""></li>\n                <li><img src="images/02.jpg" alt=""></li>\n                <li><img src="images/03.jpg" alt=""></li>\n                <li><img src="images/04.jpg" alt=""></li>\n                <li><img src="images/05.jpg" alt=""></li>\n            </ul>\n        </div>\n        <div id="focusD">\n            \x3c!--左右焦点--\x3e\n            <span id="left">&lt;</span>\n            <span id="right">&gt;</span>\n        </div>\n    </div>\n```\n\n效果实现：\n\n```javascript\n<script>\n    var box = my$("box"); //获取最外面的div\n    var ad = box.children[0];  // 获取相框\n    var imgwidth = ad.offsetWidth; // 获取相框的宽\n    var ulObj = ad.children[0];  // 获取ul\n    var focusD = my$("focusD"); // 获取左右焦点的div\n\n    // 显示和隐藏左右焦点的div----为box注册事件\n    box.onmouseover = function() {\n        focusD.style.display = "block";\n    };\n    box.onmouseout = function() {\n        focusD.style.display = "none";\n    }\n\n    // 注册点击事件\n    // 点击右侧按钮\n    var index = 0;\n    my$("right").onclick = function() {\n        if (index < ulObj.children.length - 1) {\n            index++;\n            animate(ulObj, -index * imgwidth);\n        }\n\n    }\n\n    // 点击左侧按钮\n    my$("left").onclick = function() {\n        if (index > 0) {\n            index--;\n            animate(ulObj, -index * imgwidth);\n        }\n    }\n\n    //动画函数\n    function animate(element, target) {\n        var timeid = setInterval(function() { //   设置定时器\n            var cur = element.offsetLeft; //   获取div的初始位置\n            var stp = 10; //   设置移动步数\n            stp = cur < target ? stp : -stp; //当前位置的值小于目标位置的值的话就是从左往右走， 步数是正数，  否则， 就是从右往左走，  步数的负数\n\n            cur += stp; // 获取每次移动后的位置\n            //   判断是否到达目标位置，没到的话就设置div当前的位置，如果到了的话就清除定时器\n            if (Math.abs(target - cur) > Math.abs(stp)) { //  涉及到  从左往右走 与从右往左走  的问题  ，  注意： 是距离的比较\n                element.style.left = cur + "px";\n            } else {\n                clearInterval(timeid);\n                element.style.left = target + "px"; //如果每次移动的步数不是整数10的话，  就会出现到不了目标位置的现象， 这个时候不需要再走10步，直接设置为目标位置就可以了\n            }\n        }, 20);\n    }\n<\/script>\n```\n\n#### 1.3 添加无缝效果实现一个完整的轮播图\n\n效果描述：\n\n1. 打开页面时呈现自动轮播效果\n2. 鼠标经过底部数字呈现对应图片\n3. 鼠标进入轮播框出现左右焦点\n4. 点击右侧焦点实现无缝连接效果（最后一张图片的next是第一张图片）\n\n布局：\n\n```html\n<div class="all" id="box">\n    <div class="screen">\n        \x3c!--相框--\x3e\n        <ul>\n            <li><img src="images/1.jpg" width="500" height="200" /></li>\n            <li><img src="images/2.jpg" width="500" height="200" /></li>\n            <li><img src="images/3.jpg" width="500" height="200" /></li>\n            <li><img src="images/4.jpg" width="500" height="200" /></li>\n            <li><img src="images/5.jpg" width="500" height="200" /></li>\n        </ul>\n        <ol>\n        </ol>\n    </div>\n    <div id="arr">\n        <span id="left">&lt;</span><span id="right">&gt;</span>\n    </div>\n</div>\n```\n\n效果实现：\n\n```javascript\n<script>\n    var box = my$("box"); // 获取最外面的div\n    var screen = box.children[0]; //获取相框\n    var imgWidth = screen.offsetWidth; //获取相框的宽度\n    var ulObj = screen.children[0]; //获取ul\n    var list = ulObj.children; //获取ul中的所有的li\n    var olObj = screen.children[1]; //获取ol\n    var arr = my$("arr"); //获取焦点的div\n    var pic = 0;\n\n    for (var i = 0; i < list.length; i++) { //创建小按钮---根据ul中li 的个数\n        //创建li标签，  加入到ol中\n        var liObj = document.createElement("li");\n        olObj.appendChild(liObj);\n        liObj.innerHTML = (i + 1);\n        //在每个ol中的li标签上添加一个自定义属性，存储索引值\n        liObj.setAttribute("index", i);\n        //排他功能事件\n        //注册鼠标进入事件\n        liObj.onmouseover = function() {\n            //先干掉所有的ol中的li中的背景颜色\n            for (var j = 0; j < olObj.children.length; j++) {\n                olObj.children[j].removeAttribute("class");\n            }\n            //设置当前鼠标进来的li的背景颜色\n            this.className = "current";\n            //获取鼠标进入的当前的li的当前的索引值\n            pic = this.getAttribute("index");\n            //移动ul\n            animate(ulObj, -pic * imgWidth);\n        };\n    }\n    //设置ol中第一个小按钮有背景颜色\n    olObj.children[0].className = "current";\n    //克隆一个ul中第一个li，加入到ul中的最后\n    ulObj.appendChild(ulObj.children[0].cloneNode(true)); //克隆出来的是ul的第一个子节点， 里面传入的是true，就是克隆出来的跟原来是一样的，包括它原有的属性;将克隆出来的第一个子节点追加到ul的最后\n\n    //打开页面之后的自动播放效果\n    var timeId = setInterval(clickHandle, 1000);\n\n    //鼠标进入到box的div显示左右焦点的div\n    box.onmouseover = function() {\n        arr.style.display = "block";\n        clearInterval(timeId); //当鼠标进入的时候就清理掉之前的定时器\n    }\n    //鼠标离开box的div隐藏左右焦点的div\n    box.onmouseout = function() {\n        arr.style.display = "none";\n        timeId = setInterval(clickHandle, 1000); // 鼠标离开之后继续自动播放\n    }\n\n    //右边焦点\n    my$("right").onclick = clickHandle;\n\n    function clickHandle() {\n        if (pic == list.length - 1) { //pic==5的时候，将要显示的是第6张图，用户看到的是第一张，此时应该将索引瞬间置0\n            pic = 0;\n            ulObj.style.left = 0 + "px";\n        }\n\n        pic++; //如果不满足以上的if条件句，索引+1， 正常执行\n        animate(ulObj, -pic * imgWidth);\n\n        //以下if-else语句，实现的是右侧焦点与底部按钮的同步效果\n        //如果pic==5，，出去了5张图片，此时显示的是第6个图，但是内容是第1张图片--第一个小按钮有颜色\n        if (pic == list.length - 1) {\n            olObj.children[olObj.children.length - 1].className = ""; //第5个按钮颜色干掉\n            olObj.children[0].className = "current"; //第一个按钮设置颜色\n        } else { //正常的排他功能\n            //干掉所有的小按钮的背景颜色\n            for (var i = 0; i < olObj.children.length; i++) {\n                olObj.children[i].removeAttribute("class");\n            }\n            //设置当前背景颜色\n            olObj.children[pic].className = "current"; //点击右侧焦点的时候，实现与右下角对应按钮同步效果\n        }\n\n    }\n\n    //左边焦点\n    my$("left").onclick = function() {\n        //当前在第一张图片，再点击左侧焦点的时候，  要先跳到第6张图片，再移动第5张图片\n        if (pic == 0) {\n            pic = 5;\n            ulObj.style.left = -pic * imgWidth + "px"; //如果不加px,会从第一张滑到第5张，   加了pc之后，就会直接跳转到第5张图片--无缝连接的效果\n        }\n        pic--;\n        animate(ulObj, -pic * imgWidth);\n        //设置小按钮的颜色\n        //排他功能\n        for (var i = 0; i < olObj.children.length; i++) { //所有的小按钮干掉颜色\n            olObj.children[i].removeAttribute("class");\n        }\n        olObj.children[pic].className = "current"; //设置当前对应小按钮的颜色\n    };\n\n\n    //动画函数\n    function animate(element, target) {\n        var timeid = setInterval(function() { // 设置定时器\n            var cur = element.offsetLeft; // 获取div的初始位置\n            var stp = 10; // 设置移动步数\n            stp = cur < target ? stp : -stp; //当前位置的值小于目标位置的值的话就是从左往右走， 步数是正数， 否则， 就是从右往左走， 步数的负数 // 获取每次移动后的位置 cur +=stp; //\n            cur += stp;\n            //判断是否到达目标位置， 没到的话就设置div当前的位置， 如果到了的话就清除定时器\n            if (Math.abs(target - cur) > Math.abs(stp)) { // 涉及到 从左往右走 与从右往左走 的问题 ， 注意：是距离的比较\n                element.style.left = cur + "px";\n            } else {\n                clearInterval(timeid);\n                element.style.left = target + "px"; //如果每次移动的步数不是整数10的话， 就会出现到不了目标位置的现象， 这个时候不需要再走10步，直接设置为目标位置就可以了\n            }\n        }, 10);\n    }\n<\/script>\n```\n\n**总结： 实现一个完整轮播图的整体思路：**\n\n1. 根据ul中的li的个数（图片的个数）动态创建li，并添加到ol中作为小按钮使用\n\n2.  先把索引保存在每个li的自定义属性中，为ol中的每个li添加鼠标进入的事件 ， 鼠标进入li中时做排他（背景颜色改变），移动图片（图片是整体移动，即调用动画函数移动ul ， 每次移动的是一个图片的宽度，图片的宽度就是相框的宽度：索引值*图片的宽度，注意：将索引值提前存储在一个全局变量pic中）\n\n3.  创建li之后：   设置ol中的第一个li中有默认的背景颜色；  把ul中的第一个li克隆一下（目的是做无缝连接的效果），追加到ul中所有li的最后面，使得最后一个图片和第一个图片是同一张\n\n4.  左右焦点的div显示和隐藏\n\n5.  为左右焦点注册点击事件：\n\n   每一次点击右边的按钮，先判断pic的值是不是ul中li的length-1 （即判断pic的值是不是等于5）， 如果是，此时设置pic的值为0，同时设置ul距离左边的left值为0（初始值），pic+1，移动ul，用户看到的就是第2个图片 设置小按钮的背景颜色；  左边的按钮，需要判断pic的值是不是0，如果是0，此时pic=5，ul的left的值==5*图片的宽度，立刻pic-1,然后ul移动一张图片， 此时，用户看到的是第5张图片，即实现无缝效果 。\n\n6.  自动播放效果：  在页面加载的时候，启动一个定时器，里面调用的就是右边按钮的点击事件的处理函数 ， 鼠标进入： 停止；  鼠标离开，继续自动播放 。\n\n\n### 2. 在频繁触摸的情况下，有使用什么优化吗？\n\n问题2、3、4实际上就是在考察函数节流与函数防抖。\n\n```\n首先要明确的是，这两种方式的本质都是节约性能：\n函数节流： 规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。\n函数防抖： 在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。\n```\n\n#### 2.1 函数节流：\n\n```javascript\nfunction fn() {  }  // 需要执行的具体操作\nvar cd = false;  // 设置一个指示变量，判断是不是需要执行fn\nfunction throttle(fn, time) {\n    if (cd) {\n        //\n    } else {\n        fn();\n        cd = true;\n        setTimeout(function () {\n            cd = false;\n        }, time)\n    }\n}\n```\n\n指示变量在全局环境下，如果将其设置为局部环境？ --- 考点：立即执行函数与闭包的使用\n\n```javascript\n(function () {\n    var cd = false;\n    function jieliu(fn, time) {\n        if (cd) {\n            //\n        } else {\n            fn();\n            cd = true;\n            setTimeout(function () {\n                cd = false;\n            }, time)\n        }\n    }\n    return jieliu;\n}).()\n```\n\n#### 2.2 函数防抖\n\n```javascript\nlet timer = null;\nlet isfirst = true;\n\nfunction fd(fn,time) {\n    if (timer) {\n      clearInterval(timer);\n    } else {\n      timer = setTimeout(function () {\n       \tfn();\n        timer = null;\n      }, time);\n    }\n}\n```\n\n这个防抖函数的问题在于，开始是不会执行的，需要等time毫秒之后才会生效，如何设置一开始就是实现某一个具体操作的？\n\n```javascript\nlet timer = null;\nlet isfirst = true;\n\nfunction fd(time) {\n  if (isfirst) {\n\n  }else {\n    if (timer) {\n      clearInterval(timer);\n    } else {\n      timer = setTimeout(function () {\n        //\n      }, time);\n    }\n  }\n}\n```\n\n### 3. 一个有很多图片的长页面如何优化\n\n懒加载，如何实现？\n\n```\n懒加载也叫延迟加载，当用户需要访问时，再去加载，这样可以提高网站的首屏加载速度，提升用户的体验，并且可以减少服务器的压力。懒加载的实现原理是，将页面上的图片的 src 属性设置为某一个默认图片，将图片的真实路径保存在一个自定义属性中，当页面滚动的时候，进行判断，如果图片进入页面可视区域内，则从自定义属性中取出真实路径赋值给图片的 src 属性，以此来实现图片的延迟加载。\n```\n\n需要注意的是：之前看到的懒加载的方式是这样说的：将页面上的图片的 src 属性设置为空字符串，将图片的真实路径保存在一个自定义属性中，... 这样的处理方式并没有很好的减轻服务器的压力，因为src为空字符串的时候同样会发出http请求。\n\n### 4. 写一个深比较函数`function deepCompaire(a, b){ }` ，a和b是两个对象，如果相同输出为true，如果不同输出为false\n\n**考点： 递归的应用**\n\n实现思路：\n\n```javascript\nfunction isEq(obj1, obj2) {\n  let obj1Keys = Object.keys(obj1);  // 获取第一个对象属性组成的数组\n  let obj2Keys = Object.keys(obj2);  // 获取第二个对象属性组成的数组\n\n  if (obj1Keys.length !== obj2Keys.length) return false;  // 如果得到的这两个数组的长度不相等，直接返回false\n\n  let keys = obj1Keys.concat(obj2Keys);  // 获取两个对象的公共属性\n  let uKey = uniq(keys);  // 去重\n\n  if (obj1Keys.length !== uKey.length || obj2Keys.length !== uKey.length) return false;  // 如果任何一个对象与这个公共属性数组长度不相同就直接返回false\n\n  if (typeof obj1 === \'object\') {\n    if (typeof obj2 !== \'object\') return false;  // 类型不一致，直接返回false\n    for (const i in obj1) {\n      if (!isEq(obj1[i], obj2[i])) return false;  // 递归\n    }\n    // 遍历完成后没有return值说明是相等的\n    return true;\n  }else {\n    return obj1 === obj2;\n  }\n}\n\n// 数组去重\nfunction uniq(arr) {\n  let ret = [];\n  arr.forEach(function (item) {\n    if (ret.indexOf(item) === -1) {\n      ret.push(item);\n    }\n  });\n  return ret;\n}\n\n// 测试：\nvar temp1 = { a: 0, b: { x: 1, y: 1 }, c: 0 };\nvar temp2 = { a: 0, b: { x: 1, y: 1 }, c: 0 };\nconsole.log(isEq(temp1, temp2)); // true\n\ntemp1 = { a: {m:1}, b: { x: 1, y: 1 }, c: 0 };\ntemp2 = { a: 0, b: { x: 1, y: 1 }, c: 0 };\nconsole.log(isEq(temp1, temp2));  // false\n\ntemp1 = { a: 0, b: { x: 1, y: 1 }, c: 0, d: undefined};\ntemp2 = { a: 0, b: { x: 1, y: 1 }, c: 0 };\nconsole.log(isEq(temp1, temp2)); // false\n```\n\n上面的第3个测试案例的结果是false，但是访问一个对象中原本不存在的一个属性的时候结果就是undefined，所以像第3个测试案例这样的应该是返回true才对，如何过滤掉undefined？ --- 思路：在进行深比较之前过滤掉值为undefined的属性就可以了。\n```javascript\nfunction isEq(object1, object2) {\n\n  // 过滤掉undefined的情况\n  let obj1 = filterUn(object1);\n  let obj2 = filterUn(object2);\n\n  let obj1Keys = Object.keys(obj1);  // 获取第一个对象的键组成的数组\n  let obj2Keys = Object.keys(obj2);  // 获取第二个对象的键组成的数组\n\n  if (obj1Keys.length !== obj2Keys.length) return false;  // 如果得到的这两个数组的长度不相等，直接返回false\n\n  let keys = obj1Keys.concat(obj2Keys);  // 获取两个对象的公共属性后去重\n  let uKey = uniq(keys);\n\n  if (obj1Keys.length !== uKey.length || obj2Keys.length !== uKey.length) return false;  // 如果任何一个对象与这个公共属性数组长度 不相同就直接返回false\n\n  if (typeof obj1 !== \'undefined\') {\n    if (typeof obj1 === \'object\') {\n      if (typeof obj2 !== \'object\') return false;\n      for (const i in obj1) {\n        if (!isEq(obj1[i], obj2[i])) return false;\n      }\n      return true;\n    } else {\n      return obj1 === obj2;\n    }\n  }\n}\n\n\n// 过滤undefined\nfunction filterUn(obj) {\n  for (const key in obj) {\n    if (obj.hasOwnProperty(key)) {\n        if (typeof obj[key] === "undefined" ) {\n          delete obj[key];\n        }\n    }\n  }\n\n  return obj;\n}\n\nfunction uniq(arr) {\n  let ret = [];\n  arr.forEach(function (item) {\n    if (ret.indexOf(item) === -1) {\n      ret.push(item);\n    }\n  });\n\n  return ret;\n}\n\n// 测试\nlet temp1 = { a: 0, b: { x: 1, y: 1 }, c: 0, d: undefined};\nlet temp2 = { a: 0, b: { x: 1, y: 1 }, c: 0 };\nconsole.log(isEq(temp1, temp2)); // true\n```\n\n\n### 5. 说一下CSS选择器的优先级\n\n```\n判断优先级时，首先我们会判断一条属性声明是否有权重，也就是是否在声明后面加上了!important。一条声明如果加上了权重，\n那么它的优先级就是最高的，前提是它之后不再出现相同权重的声明。如果权重相同，我们则需要去比较匹配规则的特殊性。\n\n一条匹配规则一般由多个选择器组成，一条规则的特殊性由组成它的选择器的特殊性累加而成。选择器的特殊性可以分为四个等级，\n第一个等级是行内样式，为1000，第二个等级是id选择器，为0100，第三个等级是类选择器、伪类选择器和属性选择器，为0010，\n第四个等级是元素选择器和伪元素选择器，为0001。规则中每出现一个选择器，就将它的特殊性进行叠加，这个叠加只限于对应的等\n级的叠加，不会产生进位。选择器特殊性值的比较是从左向右排序的，也就是说以1开头的特殊性值比所有以0开头的特殊性值要大。\n比如说特殊性值为1000的的规则优先级就要比特殊性值为0999的规则高。如果两个规则的特殊性值相等的时候，那么就会根据它们引\n入的顺序，后出现的规则的优先级最高。\n```\n\n### 6. 写一段代码，说一下它的输出结果\n\n```javascript\nnew Promise((resolve) => {\n  Promise.resolve().then(\n    () => console.log(1)\n  )\n  resolve()\n}).then(() => {\n  console.log(2)\n})\nnew Promise((resolve) => {\n  console.log(3)\n  resolve()\n}).then(() => {\n  console.log(4)\n  setTimeout(() => console.log(5))\n})\nsetTimeout(() => console.log(6))\nconsole.log(7)\n\n// 正确答案： 3712465\n```\n\n**考点： JS的事件执行机制**\n\n浏览器中的事件循环机制是这样的：执行同步任务 ---\x3e 执行异步任务（宏任务和微任务）\n\n其中异步任务的执行机制是这样的：\n  - 执行一只task（宏任务）\n  - 执行完micro-task队列（微任务）\n\n如此循环往复下去。\n\n那么什么是宏任务什么是微任务呢？\nmacro task（宏任务）: 同步代码(整块script代码)、setImmediate、MessageChannel、setTimeout/setInterval\nmicro task（微任务）: Promise.then（不是promise，promise会立即执行）、MutationObserver，还有process.nextTick等。\n\n![JS执行机制](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9xcWFkYXB0LnFwaWMuY24vdHhkb2NwaWMvMC9kN2VjMmFiYTVjOTk1ZTQ4ODlmYTU1YzZhYjMyM2E5Ni8w?x-oss-process=image/format,png)\n\n![事件循环、宏任务，微任务的关系如图](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9xcWFkYXB0LnFwaWMuY24vdHhkb2NwaWMvMC84NTRlOTMzM2QzZWQ0MzM1OTQxZjM1MDc1Mjc3NGI1My8w?x-oss-process=image/format,png)\n\n分析上述代码的执行流程：\n- 首先，整段代码作为宏任务，进入主线程\n- 遇到`new Primise`立即执行，还是一个Promise，将这个Promise的then回调函数注册分发到微任务事件队列A中，即现在事件队列A中的代码块是`[() => console.log(1)]`，然后`new Primise`的then回调函数也注册分发到微任务事件队列A中，此时事件队列A中为`[() => console.log(1), console.log(2)]`\n- 继续执行，遇到第二个、`new Promise`立即执行，这时在控制台输出的是数字3，然后把then回调函数注册分发到微任务事件队列A中，此时，事件队列A为`[() => console.log(1), console.log(2), console.log(4), setTimeout(() => console.log(5))]`\n- 继续执行，遇到setTimeout，将其回调函数注册分发到宏任务事件队列B中，此时B中为`[() => console.log(6)]`\n- 继续执行，遇到同步代码`console.log(7)`直接在控制台中输出数字7\n- 到这里，script作为第一个宏任务就执行完了，根据浏览器的Event Loop，接下来需要执行的是微任务事件队列A，事件的执行是先入先出，所以在控制台中依次输出的数字是124, 再往后执行的时候遇到的是一个宏任务setTimeout，将其回调函数`() => console.log(5)`push到宏任务事件队列B中，此时B中为`[() => console.log(6), () => console.log(5)]`\n- 至此，微任务事件队列全部执行完毕，然后去执行宏任务事件队列B，在控制台输出65\n- 所以在控制台中输出的最终结果是：3712465。\n'}});
//# sourceMappingURL=0.661c73b484ec7fc4a14d.js.map