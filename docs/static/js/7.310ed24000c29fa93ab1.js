webpackJsonp([7],{IYMr:function(e,n){e.exports="# vue响应式系统\r\n\r\nVue官方在[深入响应式原理](https://cn.vuejs.org/v2/guide/reactivity.html)这一节中，这样解释响应式系统的含义：\r\n> Vue 最独特的特性之一，是其非侵入性的响应式系统。数据模型仅仅是普通的 JavaScript 对象。而当你修改它们时，视图会进行更新。这使得状态管理非常简单直接，不过理解其工作原理同样重要，这样你可以避开一些常见的问题。在这个章节，我们将研究一下 Vue 响应式系统的底层的细节。\r\n\r\n然而这个解释实在太简洁了，至少我第一读到这里的时候，完全不知道说的是什么。相信每个刚开始接触Vue框架的新手，都会有相同的感觉 :dizzy_face:\r\n\r\n不过请放心，通过阅读下面的内容，你将会了解到：\r\n* 响应式系统的含义\r\n* 如何监测数据的变化\r\n* 为什么需要发布订阅模式\r\n* 实现一个响应式系统\r\n\r\n## 什么是响应式系统\r\n\r\n我们先来看一个非常简单的例子：\r\n```HTML\r\n<div id=\"app\">\r\n    {{name}}\r\n</div>\r\n\r\n```\r\n\r\n``` javascript\r\n<script>\r\n    const myVue = new Vue({\r\n        el: '#app',\r\n        data: {\r\n            name: 'Rana'\r\n        }\r\n    })\r\n<\/script>\r\n```\r\n打开浏览器，此时Vue实例数据中name的值被自动地渲染在了视图中。打开控制台，输入 `myVue.$data.name = \"随便你想输入的任何值都可以\"`并回车，你会发现对应的视图也会自动地发生变化。\r\n\r\n响应式系统（Reactive system）就是指数据的变化**自动地**导致视图的更新。这种**自动地**变化，就是指**响应式**。\r\n\r\n举例来说：\r\n在MVVM设计架构中，ViewModel通过双向数据的绑定，使得View的变化自动地反应到ViewModel上，反之亦然，从而确保View中显示的数据和Model中存储的数据是同步的。这就叫响应式系统。\r\n在Vue中。Vue实例里数据的变化，也会自动地反应到对应的视图上去，即对应的视图会自动地更新，反之亦然。这也叫响应式系统。\r\n\r\n现在你应该明白[Vue官方文档](https://cn.vuejs.org/v2/guide/reactivity.html)里面\r\n>数据模型仅仅是普通的 JavaScript 对象。而当你修改它们时，视图会进行更新。\r\n\r\n这句话的含义了吧。\r\n\r\n总结：响应式系统就是指数据的变化与视图的更新是**同步的**。  \r\n\r\n\r\n## 如何监测数据的变化\r\n\r\n那么Vue是如何实现响应式系统的呢？\r\n\r\n从响应式系统的含义可知：数据变化，视图自动变化\r\n因此，要实现响应式系统，第一步就需要**监测**数据的变化。\r\n\r\n而监测数据的变化，用专业的话表示，就是指**数据劫持**。\r\n\r\n数据劫持的实现方式有两种：[Object.defineProperty](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)和ES6新增的[Proxy](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy)，两者的区别可以查看下一节。总的来说，Object.defineProperty 是对一个对象的属性进行劫持，而 Proxy 则是对整个对象进行劫持。\r\n\r\nObject.defineProperty(obj, prop, descriptor) 的第三个参数 descriptor 可以定义get和set两个函数。其中，get 函数是属性的 getter 函数，当访问该属性的时候会触发此 get 函数。set函数是属性的 setter 函数，当修改该属性所对应的值的时候，会触发此 set 函数。\r\n\r\n我们举一个简单的例子来说明使用 Object.defineProperty 进行数据劫持：\r\n\r\n使用一个p标签作为输出的位置。\r\n``` HTML\r\n<div>\r\n    <p id=\"p\"></p>\r\n</div>\r\n\r\n```\r\n在js代码中，我们定义了一个含有name属性的对象，该属性的值是Rana。此外，我们把object.name的值通过p标签显示出来。\r\n然后，通过 Object.defineProperty 我们给object对象的name属性设置了get和set函数，实现数据的劫持。当访问name属性的时候，会触发get函数，控制台打印出'Get!'以及name属性对应的值value。当修改name属性的时候，触发set函数，控制台打印出'Set!'以及修改后的值，这时候我们用newValue替换原来的value实现数据的更新，并把更新反应到视图上。\r\n``` javascript\r\n<script>\r\n    const object = {\r\n        name: 'Rana'\r\n    }\r\n\r\n    let value = object.name\r\n\r\n    Object.defineProperty(object, 'name', {\r\n        get: function(){\r\n            console.log('Get!')\r\n            return value\r\n        },\r\n        set: function(newValue){\r\n            console.log('Set! new value is:', newValue)\r\n            value = newValue\r\n            document.getElementById('p').innerHTML = value\r\n        }\r\n    })\r\n\r\n    document.getElementById('p').innerHTML = object.name\r\n<\/script>\r\n```\r\n在控制台随意修改object.name的值，对应的视图也会发生变化。这样，我们已经实现了最简单的数据劫持！:satisfied:\r\n\r\n\r\n## 为什么需要发布订阅模式\r\n\r\n我们先来看看这个简易版数据劫持有什么问题：\r\n* 只能监测一个属性的变化。\r\n* 属性的变化只对应p标签这一个视图的更新。然而实际上数据的变化可能会对应多个视图的更新。\r\n* 数据，方法以及对DOM的操作都耦合在一起，不符合MVVM的设计思想。\r\n\r\n对于第一点，只需要遍历对象的每一个属性，给每个属性使用Object.defineProperty添加get和set就行了。我们可以使用 [Object.keys()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/keys) 这个方法得到一个由object所有属性组成的数组，对数组进行遍历：\r\n\r\n```javascript\r\n    const object = {\r\n        name: 'Rana',\r\n        age: 18,\r\n        grade: {\r\n            lastYear: 90,\r\n            thisYear: 100\r\n        }\r\n    }\r\n    function observe(object){\r\n        if(!object || typeof object !== 'object') return  //递归出口，当值不是object或者不存在时返回\r\n        Object.keys(object).forEach(key => {\r\n            defineReactive(object, key, object[key])\r\n        })\r\n    }\r\n\r\n    function defineReactive(object, key, value){\r\n        observe(value)  // 递归地遍历\r\n        Object.defineProperty(object, key, {\r\n            enumerable: true,\r\n            configurable: true,\r\n            get: () => {\r\n                console.log('Get!')\r\n                return value\r\n            },\r\n            set: (newValue) => {\r\n                console.log('Set new value is:', newValue)\r\n                value = newValue\r\n            }\r\n        })\r\n    }\r\n\r\n    observe(object)\r\n```\r\n对于object这个对象，我们使用一个 observe 函数对此对象的所有属性，调用 defineReactive 这个函数使得object所有的属性都变成响应式的。\r\n这里有一个小trick。一个对象属性对应的值可能还是一个对象，因此需要递归地遍历整个对象。此外，我们在 Object.defineProperty 中还设置了 enumerable: true 使属性可枚举，configurable: true 使属性可修改。\r\n\r\n现在你应该明白[Vue官方文档](https://cn.vuejs.org/v2/guide/reactivity.html)里面\r\n>当你把一个普通的 JavaScript 对象传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因。\r\n\r\n的含义了吧。\r\n\r\n对于第二点和第三点，这才是需要**发布订阅模式**的原因所在。:thumbsup:\r\n正是因为数据的变化可能会对应多个视图的更新，我们才需要发布订阅模式**收集**视图依赖于哪些数据，并在数据发生改变的时候，**通知**对应的视图进行更新。从而实现数据监测和视图更新的解耦。\r\n\r\n## 实现一个响应式系统\r\n\r\n让我们整理一下当前的思路，要实现响应式系统，需要以下三点：\r\n\r\n* 监测数据的改变\r\n* 收集哪些视图依赖于数据\r\n* 在数据变化的时候通知对应的视图更新\r\n\r\n翻译成专业一点的说法，就是需要实现：\r\n\r\n* 数据劫持\r\n* 依赖收集\r\n* 发布更新\r\n\r\n从编写代码的角度来说，就是需要：\r\n\r\n* 监听器Observer，用来劫持数据（即data对象的属性）。\r\n* 消息中心Dependence，用来收集订阅者，并在数据变化时，通知订阅者。\r\n* 订阅者Watcher，接收数据变化的通知，并执行相应的函数，从而更新视图。\r\n\r\n数据劫持上文已经实现了，下面我们专注于依赖收集和发布更新，这两个部分合起来就是一个[发布订阅模式](https://zh.wikipedia.org/wiki/%E5%8F%91%E5%B8%83/%E8%AE%A2%E9%98%85)。\r\n\r\n### 实现消息中心\r\n\r\n首先我们需要实现一个消息中心（dependence center）来收集订阅者，在属性变化的时候再去通知订阅者更新。\r\n把上面的话翻译成代码：\r\n\r\n``` javascript\r\n    function Dependence(){\r\n        this.subscribers = []\r\n    }\r\n    Dependence.prototype = {\r\n        addSub: function(sub){\r\n            this.subscribers.push(sub)\r\n        },\r\n        notify: function(){\r\n            this.subscribers.forEach(sub => {\r\n                sub.update()\r\n            })\r\n        }\r\n    }\r\n```\r\nDependence 函数里面有一个数组 subscribers 用于保存订阅者，Dependence 函数还拥有两个方法。addSub 用于添加订阅者，notify 用于通知订阅者更新。\r\n此时我们该稍微改动一下observe函数了：\r\n```javascript\r\n    function observe(object){\r\n        if(!object || typeof object !== 'object') return\r\n        Object.keys(object).forEach(key => {\r\n            defineReactive(object, key, object[key])\r\n        })\r\n    }\r\n\r\n    function defineReactive(object, key, value){\r\n        observe(value)\r\n        const dep = new Dependence()\r\n        Object.defineProperty(object, key, {\r\n            enumerable: true,\r\n            configurable: true,\r\n            get: () => {\r\n                if(需要添加订阅者){\r\n                    dep.addSub(watcher) //添加watcher\r\n                }\r\n                return value\r\n            },\r\n            set: (newValue) => {  //数据变化时，通知订阅者更新\r\n                value = newValue\r\n                dep.notify()\r\n            }\r\n        })\r\n    }\r\n```\r\n可见我们将添加watcher的操作放在了get函数里面，这是为了当watcher初始化的时候，触发get函数，从而把自己添加到 dependence center 中。\r\n\r\n### 实现订阅者\r\n\r\n由于我们已经把watcher添加到dependence center的操作放在了get函数里面，因此我们只需要在watcher初始化的时候，调用get函数，就能够实现添加的操作。显然，调用get函数只需要访问相关属性即可。\r\n把上面的话翻译成代码：\r\n\r\n``` javascript\r\n    function Watcher(vm, expression, callbackFunc){\r\n        this.callbackFunc = callbackFunc\r\n        this.vm = vm\r\n        this.expression = expression\r\n        this.value = this.get()\r\n    }\r\n\r\n    Watcher.prototype = {\r\n        get: function() {\r\n            Dep.target = this\r\n            let value = this.vm.$data[this.expression]\r\n            Dep.target = null\r\n            return value\r\n        },\r\n        update: function(){\r\n            this.run()\r\n        },\r\n        run: function(){\r\n            let newValue = this.vm.$data[this.expression]\r\n            let oldValue = this.value\r\n            if(newValue !== oldValue){\r\n                this.value = newValue\r\n                this.callbackFunc.call(this.vm, newValue)\r\n            }\r\n        }\r\n    }\r\n```\r\n我们在watcher的get函数里面，触发了响应式对象的get函数，从而使得该watcher被添加到 dependence center 中。\r\n我们还设计了对应的update方法，该方法在被调用时，先判断数据是否发生了变化，若有，则调用回调函数更新视图。\r\n\r\n此时，再修改一下defineReactive函数：\r\n```javascript\r\n    let Dep = {}\r\n    Dep.target = null\r\n    function defineReactive(object, key, value){\r\n        observe(value)\r\n        const dep = new Dependence()\r\n        Object.defineProperty(object, key, {\r\n            enumerable: true,\r\n            configurable: true,\r\n            get: () => {\r\n                if(Dep.target){\r\n                    dep.addSub(Dep.target)\r\n                }\r\n                return value\r\n            },\r\n            set: (newValue) => {\r\n                value = newValue\r\n                dep.notify()\r\n            }\r\n        })\r\n    }\r\n```\r\n\r\n最后，只需要定义一个我们自己的Vue构造函数，把上面这些内容汇总在一起就行：\r\n\r\n```javascript\r\n    function MyVue (data, element, expression) {\r\n        this.$data = data\r\n        observe(data)\r\n        element.innerHTML = this.$data[expression]\r\n        new Watcher(this, expression, function (newValue) {\r\n            element.innerHTML = newValue\r\n        })\r\n        return this\r\n    }\r\n```\r\n\r\n测试一下：\r\n\r\n```HTML\r\n<body>\r\n    <h1 id=\"name\">{{name}}</h1>\r\n</body>\r\n<script>\r\n    const element = document.querySelector('#name');\r\n    const myVue = new MyVue({\r\n            name: 'Rana'\r\n        }, element, 'name')\r\n    window.setTimeout(function(){\r\n        myVue.$data.name = 'New name!'\r\n    }, 1000)\r\n<\/script>\r\n        \r\n```\r\n页面上会显示正确的值，一秒钟以后还会变成 `New name!`，你可以通过在控制台 `myVue.$data.name = '随便什么值都行'` 来看到页面发生变化。至此，一个完整的符合MVVM架构的响应式系统基本完成。\r\n\r\n现在你应该能够明白[Vue官方文档](https://cn.vuejs.org/v2/guide/reactivity.html)里面\r\n>每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把“接触”过的数据属性记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。\r\n"}});