webpackJsonp([2],{mMKz:function(r,n){r.exports="# JavaScript的异步\r\n\r\n在JavaScript的运行机制中我们已经了解到，JS引擎是单线程的。也就是说，JS引擎一次只能执行一个任务，多个任务需要等待前面的任务完成之后，才能继续执行下面的任务。这种单线程的机制使得JS引擎的执行机制比较简单，我们无需考虑多线程之间的协调通信。单线程的缺点在于如果当前的任务执行时间过长，那么剩余的任务需要排队等待，此时浏览器是处于无响应状态的。因此，我们需要异步：\r\n\r\n同步和异步的区别在于：\r\n[同步](https://developer.mozilla.org/zh-CN/docs/learn/JavaScript/%E5%BC%82%E6%AD%A5/%E6%A6%82%E5%BF%B5)：多个任务顺序执行。同步有可能会阻塞剩余的任务。\r\n>通常来说，程序都是顺序执行，同一时刻只会发生一件事。如果一个函数依赖于另一个函数的结果，它只能等待那个函数结束才能继续执行，从用户的角度来说，整个程序才算运行完毕。\r\n\r\n[异步](https://developer.mozilla.org/zh-CN/docs/learn/JavaScript/%E5%BC%82%E6%AD%A5/%E6%A6%82%E5%BF%B5)：JS引擎不必等待异步任务的结束，而是继续执行下去，等到异步任务有了结果之后，再执行对应的回调函数。也就是说，异步不会阻塞剩余的任务。\r\n\r\n通过阅读下面的内容，你将会了解到异步JavaScript的实现方式，具体包括：\r\n* 回调函数\r\n* 事件监听\r\n* Promise\r\n* Generator\r\n* Async + await\r\n* 实现一个Promise\r\n\r\n## 回调函数\r\n\r\n准确的来讲，应该叫异步回调函数。\r\n\r\n[异步回调函数](https://developer.mozilla.org/zh-CN/docs/learn/JavaScript/%E5%BC%82%E6%AD%A5/%E7%AE%80%E4%BB%8B)（Asynchronous Callback）：等一个耗时的异步操作有了结果之后，再调用的函数，就叫异步回调函数。\r\n>异步callbacks 其实就是函数，只不过是作为参数传递给那些在后台执行的其他函数. 当那些后台运行的代码结束，就调用callbacks函数，通知你工作已经完成，或者其他有趣的事情发生了。\r\n\r\n例如：\r\n```javascript\r\n    function myAjax(url){\r\n        const xhr = new XMLHttpRequest()\r\n        xhr.open('GET', url, true)\r\n        xhr.onreadystatechange = callback(xhr.response)\r\n        // 或者是 xhr.onload = callback(xhr.response)\r\n        xhr.responseType = 'json'\r\n        xhr.send()\r\n    }\r\n\r\n    myAjax('url')\r\n```\r\n对于 `myAjax` 来说，新建 `XMLHttpRequest` 实例，设置请求方法和调用 `send` 方法发送都是同步执行的。而 `onreadystatechange` ，或者是 `onload` ， `onerror` 则是**异步**执行的。JS引擎不会等待 `myAjax` 返回结果，而是继续向下执行代码。等到得到结果之后，再调用 `callback` 函数。\r\n\r\n回调函数非常好用，也容易理解，简单的异步操作使用回调函数完全没有问题。唯一的缺点在于层层嵌套的回调函数（基于上一个异步操作的结果进行下一个异步操作）：\r\n\r\n```javascript\r\n    doSomething(result1 => {\r\n        doMoreThing(result1, result2 => {\r\n            doMoreThing(result2, result3 => {\r\n                console.log('终于得到了最终结果：', result3)\r\n            })\r\n        })\r\n    })\r\n```\r\n\r\n层层嵌套的回调函数（回调地狱）的问题不是缩进:sweat_smile:，而是这样的代码不容易阅读（你能一眼看出来上面这个嵌套回调的关系吗？），出了问题也不容易维护（我不知道究竟是哪一步出了问题）。\r\n\r\n## 事件监听\r\n\r\n异步操作返回的时候触发一个事件，通过监听这个事件，得到异步操作的结果。还是上面的 `myAjax` 的例子，我们把 `onload` 属性改为监听 `load` 事件：\r\n\r\n```javascript\r\n    function myAjax(url){\r\n        const xhr = new XMLHttpRequest()\r\n        xhr.open('GET', url, true)\r\n        xhr.addEventListener('load', handelFunc)\r\n        xhr.responseType = 'json'\r\n        xhr.send()\r\n    }\r\n```\r\n这里的handelFunc同样是回调函数。\r\n\r\n有些地方还给出了一种基于[发布订阅模式](http://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html)的异步解决方案：\r\n\r\n>我们假定，存在一个\"信号中心\"，某个任务执行完成，就向信号中心\"发布\"（publish）一个信号，其他任务可以向信号中心\"订阅\"（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做发布订阅模式，又称观察者模式。\r\n\r\n可见发布订阅模式还是回调函数＋事件监听。\r\n\r\n## Promise\r\n\r\n上面的异步回调函数和事件监听都是 old school 的异步解决方案。它们的问题各自出在：嵌套的回调函数耦合度太高，不易维护；事件监听如果错过了就没法拿到结果了。Promise的出现彻底解决了这些问题。\r\n\r\n关于Promise的详细例子可以看[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise)或者阮一峰的[ES6教程](https://es6.ruanyifeng.com/#docs/promise)。\r\n>Promise 是一个对象，用于表示一个异步操作的最终完成 (或失败), 及其结果值。\r\n\r\n>所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。\r\n\r\n有点迷？没关系。简单的说，Promise的含义就是**承诺**：对于一个异步操作，Promise对象承诺给出一个最终的结果，这个结果可能是异步操作成功（fulfilled），也可能是失败（rejected）。但无论是哪种结果，Promise都**承诺**这个结果不会改变或者丢失（事件监听如果错过了就没法拿到结果了，而Promise无论什么时候都保存着结果），并且可以根据这个结果，调用对应的回调函数。\r\n\r\n继续上面的 `myAjax`：\r\n\r\n```javascript\r\n    function myAjaxUsingPromise(url){\r\n        return new Promise((resolve, reject) => {\r\n            const xhr = new XMLHttpRequest()\r\n            xhr.open('GET', url, true)\r\n            xhr.onload = () => {\r\n                if(xhr.status === 200){\r\n                    resolve(xhr.response)\r\n                }else{\r\n                    reject(xhr.statusText)\r\n                }\r\n            }\r\n            xhr.responseType = 'json'\r\n            xhr.send()\r\n        })\r\n    }\r\n\r\n    myAjaxUsingPromise('url')\r\n        .then((response) => {\r\n            console.log(response)\r\n        })\r\n        .catch((error) => {\r\n            console.log(error)\r\n        })\r\n```\r\n\r\n上面的代码返回了一个新的 `Promise` 实例，Promise构造函数的参数是一个函数，该函数接收两个回调函数：`resolve` 作为状态从pending变成fulfilled时的回调，`reject` 作为状态从pending变成rejected时的回调。\r\n\r\n简单的说，我们可以传递两个回调函数 `callback1` 和 `callback2` 作为异步操作成功和失败的回调。并且，关键的是，这个阶段**不需要考虑** `callback1` **和** `callback2` **的具体实现**！我们只需要关心异步操作的流程即可。在之后的 `.then .catch` 调用中，再设计回调函数的具体代码。\r\n\r\n此外，Promise可以通过链式调用的方式，解决嵌套回调：\r\n```javascript\r\n    doSomething()\r\n        .then(result1 => doMoreThing(result1))\r\n        .then(result2 => doMoreThing(result2))\r\n        .then(result3 => {\r\n            console.log('终于得到了最终结果：', result3)\r\n        })\r\n```\r\n\r\n\r\n## Generator"}});
//# sourceMappingURL=2.ab22f811af96cff6ec7b.js.map