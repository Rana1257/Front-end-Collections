webpackJsonp([4],{"yd+H":function(r,n){r.exports='# 跨域\r\n\r\n在前端实际开发过程中，只要使用了Ajax等基于 `XMLHttpRequest` 的技术（$Ajax，axios）或者是fetch，无可避免都地会遇到浏览器的跨域问题。就算你请求的是自己本地计算机上的文件，在没有设置跨域的情况下，浏览器照样会阻止你的请求。这种限制让人非常抓狂，我居然都不能访问我自己本地的文件。因此，了解这背后的罪魁祸首（误），也就是浏览器的**同源策略**，和规避同源策略的方法，也就是**跨域**，是很有必要的:sunglasses:。\r\n\r\n通过阅读下面的内容，你将会了解到：\r\n\r\n* 为什么要有同源策略？\r\n* 如何实现跨域？\r\n    * Jsonp\r\n    * 反向代理\r\n    * CORS\r\n\r\n## 为什么要有同源策略？\r\n\r\n跨域问题来自于浏览器的[同源策略](https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy)，所谓**同源**指的是两个源（Origin）的协议，域名，端口号相同，否则就不属于同一个源。举例来说，对于 `http://www.github.com/index.html` ，协议是 `http` ，域名是 `www.example.com` ，端口号是 `80` （http协议的默认端口号是80），因此：\r\n\r\n* `http://www.github.com/index2.html`：同源\r\n* `http://github.com/index.html`：不同源（域名不同）\r\n* `https://www.github.com/index.html`：不同源（协议不同）\r\n* `http://www.github.com:81/index.html`：不同源（端口不同）\r\n\r\n### 含义\r\n\r\n浏览器的**同源策略**，就是指在未经允许的情况下，一个源（比如 `www.github.com` ）不能访问另一个源（比如 `www.wikipedia.org` ）中的内容。准确的来说，同源策略主要是阻止了JavaScript脚本，对另一个域下的：\r\n\r\n* 敏感信息数据：Cookie，LocalStorage，IndexDB\r\n* DOM\r\n* AJAX 请求\r\n\r\n的操作。大部分情况下，是浏览器主动拦截了这些操作和请求的发出。当然有些情况下，可能是请求已经发送到服务器了，但是响应被浏览器拦截了。\r\n\r\n除此之外，现代的浏览器也限制了对本地文件的访问。准确地说，如果请求的 URL 不是 HTTP 或者 HTTPS，而是 `file:///` 这样的形式，那么依然不符合同源策略，就算你使用了跨域，浏览器照样会进行拦截，详见[这里](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS/Errors/CORSRequestNotHttp)。可以说，随着互联网的发展，同源政策变得越来越严格。\r\n\r\n### 作用\r\n\r\n同源政策的作用就是为了防止某个网页上的恶意脚本访问另一个页面上的敏感数据。因为Web应用广泛依赖于Cookie来记录用户的状态信息，因此必须将不相关的网页隔离开来，防止敏感数据泄露。\r\n>设想这样一种情况：A网站是一家银行，用户登录以后，又去浏览其他网站。如果其他网站可以读取A网站的 Cookie，那么这些信息就会泄漏。更可怕的是，Cookie 往往用来保存用户的登录状态，如果用户没有退出登录，其他网站就可以冒充用户，为所欲为。由此可见，"同源政策"是必需的，否则 Cookie 可以共享，互联网就毫无安全可言了。\r\n\r\n现在你明白为什么需要有同源策略这种限制了吧？同源策略可以说是浏览器安全的基石，没有它 "互联网就毫无安全可言了" 。遗憾的是，同源策略不能完全避免所有的网络攻击（比如跨站请求伪造CSRF）。\r\n\r\n## 实现跨域\r\n\r\n实际开发中的跨域问题主要是出现在用Ajax获取其他源上的数据，为了规避同源策略的影响，我们将在下面介绍三种主流的跨域方法。虽然跨域还有其他许多方案，不过因为应用场景太少，实在是没有了解的必要:joy:。\r\n\r\n### JSONP\r\n\r\n'}});