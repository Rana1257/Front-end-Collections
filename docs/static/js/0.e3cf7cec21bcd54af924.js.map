{"version":3,"sources":["webpack:///./static/2.md"],"names":["module","exports"],"mappings":"qCAAAA,EAAAC,QAAA","file":"static/js/0.e3cf7cec21bcd54af924.js","sourcesContent":["module.exports = \"# 面经汇总\\r\\n\\r\\n## 七牛云一面 60min\\r\\n\\r\\n对本次面试进行复盘总结之前，先来谈一下面试体验好了：\\r\\n\\r\\n面试官人非常nice，遇到不会的问题，写不出来的代码，他会一直引导你带你实现，主要是面试官**颜值爆表**！！！hhhh~\\r\\n\\r\\n问题总结：\\r\\n\\r\\n1、项目中的轮播是如何实现的？ 如果让你手写一个轮播效果，你会如何实现？ \\r\\n\\r\\n2、在频繁触摸的情况下，有使用什么优化吗？\\r\\n\\r\\n3、打开屏幕共享实现以下函数节流？能不能修改成一个比较通用的函数？写的指示变量是在全局环境下的，有什么办法可以避免全局变量污染呢？\\r\\n\\r\\n4、函数防抖也写一下？\\r\\n\\r\\n5、像你的项目中一个页面比较长，会有很多的图片，如果同时加载过来的话性能肯定是比较低的，有什么方法优化呢？\\r\\n\\r\\n6、写一个深比较函数`function deepCompaire(a, b){ }` ，a和b是两个对象，如果相同输出为true，如果不同输出为false\\r\\n\\r\\n7、在实现上述深比较函数时用到了数组去重，不要用ES6的Set，自己写一个数组去重函数？\\r\\n\\r\\n8、 优化这个深比较函数，一个对象中的某个属性值可能是undefined，如何过滤掉这种情况？\\r\\n\\r\\n9、CSS选择器的优先级说一下\\r\\n\\r\\n10、写一段代码，说出输出结果。\\r\\n\\r\\n\\r\\n\\r\\n接下来，依次对上述问题进行分析总结：\\r\\n\\r\\n### 1、项目中的轮播是如何实现的？\\r\\n\\r\\n回答使用的是vue-awesome-swiper插件，说完立马就开始让我实现一个轮播了！回答的不好，当时确实思路不太清晰\\r\\n\\r\\n#### 1.1 实现一个最简单的轮播图\\r\\n\\r\\n效果描述：有6张图片，在轮播框的下放有对应的6个序号，鼠标放在对应的序号上显示对应的图片：\\r\\n\\r\\n布局：\\r\\n\\r\\n```html\\r\\n<div class=\\\"box\\\" id=\\\"box\\\">\\r\\n    <div class=\\\"inner\\\">\\r\\n        <!--相框-->\\r\\n        <ul>\\r\\n            <li>\\r\\n                <a href=\\\"#\\\"><img src=\\\"images/1.jpg\\\" alt=\\\"\\\" /></a>\\r\\n            </li>\\r\\n            <li>\\r\\n                <a href=\\\"#\\\"><img src=\\\"images/2.jpg\\\" alt=\\\"\\\" /></a>\\r\\n            </li>\\r\\n            <li>\\r\\n                <a href=\\\"#\\\"><img src=\\\"images/3.jpg\\\" alt=\\\"\\\" /></a>\\r\\n            </li>\\r\\n            <li>\\r\\n                <a href=\\\"#\\\"><img src=\\\"images/4.jpg\\\" alt=\\\"\\\" /></a>\\r\\n            </li>\\r\\n            <li>\\r\\n                <a href=\\\"#\\\"><img src=\\\"images/5.jpg\\\" alt=\\\"\\\" /></a>\\r\\n            </li>\\r\\n            <li>\\r\\n                <a href=\\\"#\\\"><img src=\\\"images/6.jpg\\\" alt=\\\"\\\" /></a>\\r\\n            </li>\\r\\n        </ul>\\r\\n        <div class=\\\"square\\\">\\r\\n            <span class=\\\"current\\\">1</span>\\r\\n            <span>2</span>\\r\\n            <span>3</span>\\r\\n            <span>4</span>\\r\\n            <span>5</span>\\r\\n            <span>6</span>\\r\\n        </div>\\r\\n    </div>\\r\\n</div>\\r\\n```\\r\\n\\r\\n轮播实现：\\r\\n\\r\\n```javascript\\r\\n<script>\\r\\n\\tvar box = my$(\\\"box\\\"); // 获取最外面的div\\r\\n\\tvar inner = box.children[0]; // 获取相框\\r\\n\\tvar imgWidth = inner.offsetWidth; // 获取相框的宽度\\r\\n\\tvar ulObj = inner.children[0]; // 获取ul\\r\\n\\tvar spanObjs = inner.children[1].children;  // 获取所有的span\\r\\n\\r\\n\\tfor (var i = 0; i < spanObjs.length; i++) { // 循环遍历所有的span标签，注册鼠标进入事件\\r\\n    \\r\\n    \\tspanObjs[i].setAttribute(\\\"idx\\\", i); //循环时，把索引值保存在每个span的自定义属性中\\r\\n    \\tspanObjs[i].onmouseover = function() { // 注册鼠标进入事件\\r\\n            for (var j = 0; j < spanObjs.length; j++) { //先干掉所有span的背景颜色\\r\\n                spanObjs[j].removeAttribute(\\\"class\\\"); //移除每个spand的类样式\\r\\n            }\\r\\n       \\r\\n        \\tthis.className = \\\"current\\\";  //设置当前的span的背景颜色\\r\\n\\r\\n        \\t//移动ul----每个图片的 宽 × 鼠标所在的span的索引值\\r\\n        \\t//获取当前鼠标进入的span的索引值\\r\\n        \\tvar idx = this.getAttribute(\\\"idx\\\");\\r\\n        \\tanimate(ulObj, -idx * imgWidth);\\r\\n    \\t};\\r\\n\\t}\\r\\n\\r\\n    function animate(element, target) {\\r\\n        clearInterval(element.timeid);\\r\\n        \\r\\n        element.timeid = setInterval(function() { // 设置定时器\\r\\n            \\r\\n            var cur = element.offsetLeft; // 获取div的初始位置\\r\\n            var stp = 10; //   设置移动步数\\r\\n            \\r\\n            stp = cur < target ? stp : -stp; //当前位置的值小于目标位置的值的话就是从左往右走， 步数是正数，  否则， 就是从右往左走，  步数是负数\\r\\n            \\r\\n            cur += stp;  // 获取每次移动后的位置\\r\\n            //   判断是否到达目标位置，没到的话就设置div当前的位置，如果到了的话就清除定时器\\r\\n            if (Math.abs(target - cur) > Math.abs(stp)) { //  涉及到  从左往右走 与从右往左走  的问题  ，  注意： 是距离的比较\\r\\n                element.style.left = cur + \\\"px\\\";\\r\\n            } else {\\r\\n                clearInterval(element.timeid);\\r\\n                element.style.left = target + \\\"px\\\"; //如果每次移动的步数不是整数10的话，  就会出现到不了目标位置的现象， 这个时候不需要再走10步，直接设置为目标位置就可以了\\r\\n            }\\r\\n        }, 20);\\r\\n    }\\r\\n</script>\\r\\n```\\r\\n\\r\\n\\r\\n\\r\\n#### 1.2 实现一个带有左右焦点的轮播图\\r\\n\\r\\n效果描述： 6张图片，点击右侧焦点时实现往左移动，点击左侧的焦点时往右移动。\\r\\n\\r\\n布局：\\r\\n\\r\\n```html\\r\\n<div id=\\\"box\\\" class=\\\"all\\\">\\r\\n        <div class=\\\"ad\\\">\\r\\n            <!--相框-->\\r\\n            <ul id=\\\"imgs\\\">\\r\\n                <li><img src=\\\"images/01.jpg\\\" alt=\\\"\\\"></li>\\r\\n                <li><img src=\\\"images/02.jpg\\\" alt=\\\"\\\"></li>\\r\\n                <li><img src=\\\"images/03.jpg\\\" alt=\\\"\\\"></li>\\r\\n                <li><img src=\\\"images/04.jpg\\\" alt=\\\"\\\"></li>\\r\\n                <li><img src=\\\"images/05.jpg\\\" alt=\\\"\\\"></li>\\r\\n            </ul>\\r\\n        </div>\\r\\n        <div id=\\\"focusD\\\">\\r\\n            <!--左右焦点-->\\r\\n            <span id=\\\"left\\\">&lt;</span>\\r\\n            <span id=\\\"right\\\">&gt;</span>\\r\\n        </div>\\r\\n    </div>\\r\\n```\\r\\n\\r\\n效果实现：\\r\\n\\r\\n```javascript\\r\\n<script>\\r\\n    var box = my$(\\\"box\\\"); //获取最外面的div\\r\\n    var ad = box.children[0];  // 获取相框\\r\\n    var imgwidth = ad.offsetWidth; // 获取相框的宽\\r\\n    var ulObj = ad.children[0];  // 获取ul\\r\\n    var focusD = my$(\\\"focusD\\\"); // 获取左右焦点的div\\r\\n\\r\\n    // 显示和隐藏左右焦点的div----为box注册事件\\r\\n    box.onmouseover = function() {\\r\\n        focusD.style.display = \\\"block\\\";\\r\\n    };\\r\\n    box.onmouseout = function() {\\r\\n        focusD.style.display = \\\"none\\\";\\r\\n    }\\r\\n\\r\\n    // 注册点击事件\\r\\n    // 点击右侧按钮\\r\\n    var index = 0;\\r\\n    my$(\\\"right\\\").onclick = function() {\\r\\n        if (index < ulObj.children.length - 1) {\\r\\n            index++;\\r\\n            animate(ulObj, -index * imgwidth);\\r\\n        }\\r\\n\\r\\n    }\\r\\n\\r\\n    // 点击左侧按钮\\r\\n    my$(\\\"left\\\").onclick = function() {\\r\\n        if (index > 0) {\\r\\n            index--;\\r\\n            animate(ulObj, -index * imgwidth);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    //动画函数\\r\\n    function animate(element, target) {\\r\\n        var timeid = setInterval(function() { //   设置定时器\\r\\n            var cur = element.offsetLeft; //   获取div的初始位置\\r\\n            var stp = 10; //   设置移动步数\\r\\n            stp = cur < target ? stp : -stp; //当前位置的值小于目标位置的值的话就是从左往右走， 步数是正数，  否则， 就是从右往左走，  步数的负数\\r\\n            \\r\\n            cur += stp; // 获取每次移动后的位置\\r\\n            //   判断是否到达目标位置，没到的话就设置div当前的位置，如果到了的话就清除定时器\\r\\n            if (Math.abs(target - cur) > Math.abs(stp)) { //  涉及到  从左往右走 与从右往左走  的问题  ，  注意： 是距离的比较\\r\\n                element.style.left = cur + \\\"px\\\";\\r\\n            } else {\\r\\n                clearInterval(timeid);\\r\\n                element.style.left = target + \\\"px\\\"; //如果每次移动的步数不是整数10的话，  就会出现到不了目标位置的现象， 这个时候不需要再走10步，直接设置为目标位置就可以了\\r\\n            }\\r\\n        }, 20);\\r\\n    }\\r\\n</script>\\r\\n```\\r\\n\\r\\n#### 1.3 添加无缝效果实现一个完整的轮播图\\r\\n\\r\\n效果描述：\\r\\n\\r\\n1. 打开页面时呈现自动轮播效果\\r\\n2. 鼠标经过底部数字呈现对应图片\\r\\n3. 鼠标进入轮播框出现左右焦点\\r\\n4. 点击右侧焦点实现无缝连接效果（最后一张图片的next是第一张图片）\\r\\n\\r\\n布局：\\r\\n\\r\\n```html\\r\\n<div class=\\\"all\\\" id=\\\"box\\\">\\r\\n    <div class=\\\"screen\\\">\\r\\n        <!--相框-->\\r\\n        <ul>\\r\\n            <li><img src=\\\"images/1.jpg\\\" width=\\\"500\\\" height=\\\"200\\\" /></li>\\r\\n            <li><img src=\\\"images/2.jpg\\\" width=\\\"500\\\" height=\\\"200\\\" /></li>\\r\\n            <li><img src=\\\"images/3.jpg\\\" width=\\\"500\\\" height=\\\"200\\\" /></li>\\r\\n            <li><img src=\\\"images/4.jpg\\\" width=\\\"500\\\" height=\\\"200\\\" /></li>\\r\\n            <li><img src=\\\"images/5.jpg\\\" width=\\\"500\\\" height=\\\"200\\\" /></li>\\r\\n        </ul>\\r\\n        <ol>\\r\\n        </ol>\\r\\n    </div>\\r\\n    <div id=\\\"arr\\\">\\r\\n        <span id=\\\"left\\\">&lt;</span><span id=\\\"right\\\">&gt;</span>\\r\\n    </div>\\r\\n</div>\\r\\n```\\r\\n\\r\\n效果实现：\\r\\n\\r\\n```javascript\\r\\n<script>\\r\\n    var box = my$(\\\"box\\\"); // 获取最外面的div\\r\\n    var screen = box.children[0]; //获取相框\\r\\n    var imgWidth = screen.offsetWidth; //获取相框的宽度\\r\\n    var ulObj = screen.children[0]; //获取ul\\r\\n    var list = ulObj.children; //获取ul中的所有的li\\r\\n    var olObj = screen.children[1]; //获取ol\\r\\n    var arr = my$(\\\"arr\\\"); //获取焦点的div\\r\\n    var pic = 0;\\r\\n\\r\\n    for (var i = 0; i < list.length; i++) { //创建小按钮---根据ul中li 的个数\\r\\n        //创建li标签，  加入到ol中\\r\\n        var liObj = document.createElement(\\\"li\\\");\\r\\n        olObj.appendChild(liObj);\\r\\n        liObj.innerHTML = (i + 1);\\r\\n        //在每个ol中的li标签上添加一个自定义属性，存储索引值\\r\\n        liObj.setAttribute(\\\"index\\\", i);\\r\\n        //排他功能事件\\r\\n        //注册鼠标进入事件\\r\\n        liObj.onmouseover = function() {\\r\\n            //先干掉所有的ol中的li中的背景颜色\\r\\n            for (var j = 0; j < olObj.children.length; j++) {\\r\\n                olObj.children[j].removeAttribute(\\\"class\\\");\\r\\n            }\\r\\n            //设置当前鼠标进来的li的背景颜色\\r\\n            this.className = \\\"current\\\";\\r\\n            //获取鼠标进入的当前的li的当前的索引值\\r\\n            pic = this.getAttribute(\\\"index\\\");\\r\\n            //移动ul\\r\\n            animate(ulObj, -pic * imgWidth);\\r\\n        };\\r\\n    }\\r\\n    //设置ol中第一个小按钮有背景颜色\\r\\n    olObj.children[0].className = \\\"current\\\";\\r\\n    //克隆一个ul中第一个li，加入到ul中的最后\\r\\n    ulObj.appendChild(ulObj.children[0].cloneNode(true)); //克隆出来的是ul的第一个子节点， 里面传入的是true，就是克隆出来的跟原来是一样的，包括它原有的属性;将克隆出来的第一个子节点追加到ul的最后\\r\\n\\r\\n    //打开页面之后的自动播放效果\\r\\n    var timeId = setInterval(clickHandle, 1000);\\r\\n\\r\\n    //鼠标进入到box的div显示左右焦点的div\\r\\n    box.onmouseover = function() {\\r\\n        arr.style.display = \\\"block\\\";\\r\\n        clearInterval(timeId); //当鼠标进入的时候就清理掉之前的定时器\\r\\n    }\\r\\n    //鼠标离开box的div隐藏左右焦点的div\\r\\n    box.onmouseout = function() {\\r\\n        arr.style.display = \\\"none\\\";\\r\\n        timeId = setInterval(clickHandle, 1000); // 鼠标离开之后继续自动播放\\r\\n    }\\r\\n\\r\\n    //右边焦点\\r\\n    my$(\\\"right\\\").onclick = clickHandle;\\r\\n\\r\\n    function clickHandle() {\\r\\n        if (pic == list.length - 1) { //pic==5的时候，将要显示的是第6张图，用户看到的是第一张，此时应该将索引瞬间置0\\r\\n            pic = 0;\\r\\n            ulObj.style.left = 0 + \\\"px\\\";\\r\\n        }\\r\\n        \\r\\n        pic++; //如果不满足以上的if条件句，索引+1， 正常执行\\r\\n        animate(ulObj, -pic * imgWidth);\\r\\n\\r\\n        //以下if-else语句，实现的是右侧焦点与底部按钮的同步效果\\r\\n        //如果pic==5，，出去了5张图片，此时显示的是第6个图，但是内容是第1张图片--第一个小按钮有颜色\\r\\n        if (pic == list.length - 1) {\\r\\n            olObj.children[olObj.children.length - 1].className = \\\"\\\"; //第5个按钮颜色干掉\\r\\n            olObj.children[0].className = \\\"current\\\"; //第一个按钮设置颜色\\r\\n        } else { //正常的排他功能\\r\\n            //干掉所有的小按钮的背景颜色\\r\\n            for (var i = 0; i < olObj.children.length; i++) {\\r\\n                olObj.children[i].removeAttribute(\\\"class\\\");\\r\\n            }\\r\\n            //设置当前背景颜色\\r\\n            olObj.children[pic].className = \\\"current\\\"; //点击右侧焦点的时候，实现与右下角对应按钮同步效果\\r\\n        }\\r\\n\\r\\n    }\\r\\n\\r\\n    //左边焦点\\r\\n    my$(\\\"left\\\").onclick = function() {\\r\\n        //当前在第一张图片，再点击左侧焦点的时候，  要先跳到第6张图片，再移动第5张图片\\r\\n        if (pic == 0) {\\r\\n            pic = 5;\\r\\n            ulObj.style.left = -pic * imgWidth + \\\"px\\\"; //如果不加px,会从第一张滑到第5张，   加了pc之后，就会直接跳转到第5张图片--无缝连接的效果\\r\\n        }\\r\\n        pic--;\\r\\n        animate(ulObj, -pic * imgWidth);\\r\\n        //设置小按钮的颜色\\r\\n        //排他功能\\r\\n        for (var i = 0; i < olObj.children.length; i++) { //所有的小按钮干掉颜色\\r\\n            olObj.children[i].removeAttribute(\\\"class\\\");\\r\\n        }\\r\\n        olObj.children[pic].className = \\\"current\\\"; //设置当前对应小按钮的颜色\\r\\n    };\\r\\n\\r\\n\\r\\n    //动画函数\\r\\n    function animate(element, target) {\\r\\n        var timeid = setInterval(function() { // 设置定时器\\r\\n            var cur = element.offsetLeft; // 获取div的初始位置\\r\\n            var stp = 10; // 设置移动步数\\r\\n            stp = cur < target ? stp : -stp; //当前位置的值小于目标位置的值的话就是从左往右走， 步数是正数， 否则， 就是从右往左走， 步数的负数 // 获取每次移动后的位置 cur +=stp; //\\r\\n            cur += stp;\\r\\n            //判断是否到达目标位置， 没到的话就设置div当前的位置， 如果到了的话就清除定时器\\r\\n            if (Math.abs(target - cur) > Math.abs(stp)) { // 涉及到 从左往右走 与从右往左走 的问题 ， 注意：是距离的比较\\r\\n                element.style.left = cur + \\\"px\\\";\\r\\n            } else {\\r\\n                clearInterval(timeid);\\r\\n                element.style.left = target + \\\"px\\\"; //如果每次移动的步数不是整数10的话， 就会出现到不了目标位置的现象， 这个时候不需要再走10步，直接设置为目标位置就可以了\\r\\n            }\\r\\n        }, 10);\\r\\n    }\\r\\n</script>\\r\\n```\\r\\n\\r\\n**总结： 实现一个完整轮播图的整体思路：**\\r\\n\\r\\n1. 根据ul中的li的个数（图片的个数）动态创建li，并添加到ol中作为小按钮使用\\r\\n\\r\\n2.  先把索引保存在每个li的自定义属性中，为ol中的每个li添加鼠标进入的事件 ， 鼠标进入li中时做排他（背景颜色改变），移动图片（图片是整体移动，即调用动画函数移动ul ， 每次移动的是一个图片的宽度，图片的宽度就是相框的宽度：索引值*图片的宽度，注意：将索引值提前存储在一个全局变量pic中） \\r\\n\\r\\n3.  创建li之后：   设置ol中的第一个li中有默认的背景颜色；  把ul中的第一个li克隆一下（目的是做无缝连接的效果），追加到ul中所有li的最后面，使得最后一个图片和第一个图片是同一张 \\r\\n\\r\\n4.  左右焦点的div显示和隐藏 \\r\\n\\r\\n5.  为左右焦点注册点击事件： \\r\\n\\r\\n   每一次点击右边的按钮，先判断pic的值是不是ul中li的length-1 （即判断pic的值是不是等于5）， 如果是，此时设置pic的值为0，同时设置ul距离左边的left值为0（初始值），pic+1，移动ul，用户看到的就是第2个图片 设置小按钮的背景颜色；  左边的按钮，需要判断pic的值是不是0，如果是0，此时pic=5，ul的left的值==5*图片的宽度，立刻pic-1,然后ul移动一张图片， 此时，用户看到的是第5张图片，即实现无缝效果 。\\r\\n\\r\\n6.  自动播放效果：  在页面加载的时候，启动一个定时器，里面调用的就是右边按钮的点击事件的处理函数 ， 鼠标进入： 停止；  鼠标离开，继续自动播放 。\\r\\n\\r\\n   \\r\\n### 2. 在频繁触摸的情况下，有使用什么优化吗？\\r\\n\\r\\n问题2、3、4实际上就是在考察函数节流与函数防抖。\\r\\n\\r\\n```\\r\\n首先要明确的是，这两种方式的本质都是节约性能：\\r\\n函数节流： 规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。\\r\\n函数防抖： 在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。\\r\\n```\\r\\n\\r\\n#### 2.1 函数节流：\\r\\n\\r\\n```javascript\\r\\nfunction fn() {  }  // 需要执行的具体操作\\r\\nvar cd = false;  // 设置一个指示变量，判断是不是需要执行fn\\r\\nfunction throttle(fn, time) {\\r\\n    if (cd) {\\r\\n        //\\r\\n    } else {\\r\\n        fn();\\r\\n        cd = true;\\r\\n        setTimeout(function () {\\r\\n            cd = false;\\r\\n        }, time)\\r\\n    }\\r\\n}\\r\\n```\\r\\n\\r\\n指示变量在全局环境下，如果将其设置为局部环境？ --- 考点：立即执行函数与闭包的使用\\r\\n\\r\\n```javascript\\r\\n(function () {\\r\\n    var cd = false;\\r\\n    function jieliu(fn, time) {\\r\\n        if (cd) {\\r\\n            //\\r\\n        } else {\\r\\n            fn();\\r\\n            cd = true;\\r\\n            setTimeout(function () {\\r\\n                cd = false;\\r\\n            }, time)\\r\\n        }\\r\\n    }\\r\\n    return jieliu;\\r\\n}).()\\r\\n```\\r\\n\\r\\n#### 2.2 函数防抖\\r\\n\\r\\n```javascript\\r\\nlet timer = null;\\r\\nlet isfirst = true;\\r\\n\\r\\nfunction fd(fn,time) {\\r\\n    if (timer) {\\r\\n      clearInterval(timer);\\r\\n    } else {\\r\\n      timer = setTimeout(function () {\\r\\n       \\tfn();\\r\\n        timer = null;\\r\\n      }, time);\\r\\n    }\\r\\n}\\r\\n```\\r\\n\\r\\n这个防抖函数的问题在于，开始是不会执行的，需要等time毫秒之后才会生效，如何设置一开始就是实现某一个具体操作的？\\r\\n\\r\\n```javascript\\r\\nlet timer = null;\\r\\nlet isfirst = true;\\r\\n\\r\\nfunction fd(time) {\\r\\n  if (isfirst) {\\r\\n\\r\\n  }else {\\r\\n    if (timer) {\\r\\n      clearInterval(timer);\\r\\n    } else {\\r\\n      timer = setTimeout(function () {\\r\\n        //\\r\\n      }, time);\\r\\n    }\\r\\n  }\\r\\n}\\r\\n```\\r\\n\\r\\n### 3. 一个有很多图片的长页面如何优化\\r\\n\\r\\n懒加载，如何实现？\\r\\n\\r\\n```\\r\\n懒加载也叫延迟加载，当用户需要访问时，再去加载，这样可以提高网站的首屏加载速度，提升用户的体验，并且可以减少服务器的压力。懒加载的实现原理是，将页面上的图片的 src 属性设置为某一个默认图片，将图片的真实路径保存在一个自定义属性中，当页面滚动的时候，进行判断，如果图片进入页面可视区域内，则从自定义属性中取出真实路径赋值给图片的 src 属性，以此来实现图片的延迟加载。\\r\\n```\\r\\n\\r\\n需要注意的是：之前看到的懒加载的方式是这样说的：将页面上的图片的 src 属性设置为空字符串，将图片的真实路径保存在一个自定义属性中，... 这样的处理方式并没有很好的减轻服务器的压力，因为src为空字符串的时候同样会发出http请求。\\r\\n\\r\\n### 4. 写一个深比较函数`function deepCompaire(a, b){ }` ，a和b是两个对象，如果相同输出为true，如果不同输出为false\\r\\n\\r\\n**考点： 递归的应用**\\r\\n\\r\\n实现思路：\\r\\n\\r\\n```javascript\\r\\nfunction isEq(obj1, obj2) {\\r\\n  let obj1Keys = Object.keys(obj1);  // 获取第一个对象属性组成的数组\\r\\n  let obj2Keys = Object.keys(obj2);  // 获取第二个对象属性组成的数组\\r\\n\\r\\n  if (obj1Keys.length !== obj2Keys.length) return false;  // 如果得到的这两个数组的长度不相等，直接返回false\\r\\n \\r\\n  let keys = obj1Keys.concat(obj2Keys);  // 获取两个对象的公共属性\\r\\n  let uKey = uniq(keys);  // 去重\\r\\n\\r\\n  if (obj1Keys.length !== uKey.length || obj2Keys.length !== uKey.length) return false;  // 如果任何一个对象与这个公共属性数组长度不相同就直接返回false\\r\\n\\r\\n  if (typeof obj1 === 'object') {\\r\\n    if (typeof obj2 !== 'object') return false;  // 类型不一致，直接返回false\\r\\n    for (const i in obj1) {\\r\\n      if (!isEq(obj1[i], obj2[i])) return false;  // 递归\\r\\n    }\\r\\n    // 遍历完成后没有return值说明是相等的\\r\\n    return true;\\r\\n  }else {\\r\\n    return obj1 === obj2;\\r\\n  }\\r\\n}\\r\\n\\r\\n// 数组去重\\r\\nfunction uniq(arr) {\\r\\n  let ret = [];\\r\\n  arr.forEach(function (item) {\\r\\n    if (ret.indexOf(item) === -1) {\\r\\n      ret.push(item);\\r\\n    }\\r\\n  });\\r\\n  return ret;\\r\\n}\\r\\n\\r\\n// 测试：\\r\\nvar temp1 = { a: 0, b: { x: 1, y: 1 }, c: 0 };\\r\\nvar temp2 = { a: 0, b: { x: 1, y: 1 }, c: 0 };\\r\\nconsole.log(isEq(temp1, temp2)); // true\\r\\n\\r\\ntemp1 = { a: {m:1}, b: { x: 1, y: 1 }, c: 0 };\\r\\ntemp2 = { a: 0, b: { x: 1, y: 1 }, c: 0 };\\r\\nconsole.log(isEq(temp1, temp2));  // false\\r\\n\\r\\ntemp1 = { a: 0, b: { x: 1, y: 1 }, c: 0, d: undefined};\\r\\ntemp2 = { a: 0, b: { x: 1, y: 1 }, c: 0 };\\r\\nconsole.log(isEq(temp1, temp2)); // false\\r\\n```\\r\\n\\r\\n上面的第3个测试案例的结果是false，但是访问一个对象中原本不存在的一个属性的时候结果就是undefined，所以像第3个测试案例这样的应该是返回true才对，如何过滤掉undefined？\\r\\n\\r\\n\\r\\n\\r\\n### 5. 说一下CSS选择器的优先级  \\r\\n\\r\\n```\\r\\n判断优先级时，首先我们会判断一条属性声明是否有权重，也就是是否在声明后面加上了!important。一条声明如果加上了权重，\\r\\n那么它的优先级就是最高的，前提是它之后不再出现相同权重的声明。如果权重相同，我们则需要去比较匹配规则的特殊性。\\r\\n\\r\\n一条匹配规则一般由多个选择器组成，一条规则的特殊性由组成它的选择器的特殊性累加而成。选择器的特殊性可以分为四个等级，\\r\\n第一个等级是行内样式，为1000，第二个等级是id选择器，为0100，第三个等级是类选择器、伪类选择器和属性选择器，为0010，\\r\\n第四个等级是元素选择器和伪元素选择器，为0001。规则中每出现一个选择器，就将它的特殊性进行叠加，这个叠加只限于对应的等\\r\\n级的叠加，不会产生进位。选择器特殊性值的比较是从左向右排序的，也就是说以1开头的特殊性值比所有以0开头的特殊性值要大。\\r\\n比如说特殊性值为1000的的规则优先级就要比特殊性值为0999的规则高。如果两个规则的特殊性值相等的时候，那么就会根据它们引\\r\\n入的顺序，后出现的规则的优先级最高。\\r\\n```\\r\\n\\r\\n### 6. 写一段代码，说一下它的输出结果\\r\\n\\r\\n```javascript\\r\\nnew Promise((resolve) => {\\r\\n  Promise.resolve().then(\\r\\n    () => console.log(1)\\r\\n  )\\r\\n  resolve()\\r\\n}).then(() => {\\r\\n  console.log(2)\\r\\n})\\r\\nnew Promise((resolve) => {\\r\\n  console.log(3)\\r\\n  resolve()\\r\\n}).then(() => {\\r\\n  console.log(4)\\r\\n  setTimeout(() => console.log(5))\\r\\n})\\r\\nsetTimeout(() => console.log(6))\\r\\nconsole.log(7)\\r\\n\\r\\n// 正确答案： 3712465\\t\\r\\n```\\r\\n\\r\\n**考点： JS的事件执行机制**\\r\\n\\r\\n浏览器中的事件循环机制是这样的：\\r\\n\\r\\n- 执行一只task（宏任务）\\r\\n- 执行完micro-task队列（微任务）\\r\\n\\r\\n如此循环往复下去。\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./static/2.md\n// module id = mMKz\n// module chunks = 0"],"sourceRoot":""}